"""
Copyright (C) 2021-2025 Mayank Vats
See license.txt

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License v3
along with this program.  If not, see <https://www.gnu.org/licenses/>.

__author__ = "Mayank Vats"
__email__ = "dev-theorist.e5xna@simplelogin.com"
__Description__ = "AuthAlpha: A package to manage Hashing and OTP generation."
__version__ = "0.9.0alpha"

"""

SCRYPT_MEM_BUFFER   = 1024 * 1024   # 1 MiB
BCRYPT_B64_SALT_LEN = 22            # 22 b64 encoded characters

class PassHashing:

    def __init__(self, algorithm):
        self.algorithm = algorithm
        self.supported_hash_methods = (
            "argon2id",
            "pbkdf2:sha1",
            "pbkdf2:sha224",
            "pbkdf2:sha256",
            "pbkdf2:sha384",
            "pbkdf2:sha512",
            "bcrypt",
            "scrypt"
        )

        if self.algorithm not in self.supported_hash_methods:
            raise TypeError(f"We don't support '{self.algorithm}' method yet. \n"
                   f"Here are the supported methods : {self.supported_hash_methods}")

    def __repr__(self):
        return "PassHashing('{}')".format(self.algorithm)

    def __str__(self):
        return f"\033[1mPassword Hashing Class [PassHashing]\033[0m. \033[92mAlgorithm:\033[0m \033" \
               f"[1m{self.algorithm}\033[0m "

    def generate_password_hash(self, password: str, salt: bytes = None, **cost_params) -> str:
        """
        :param password: type(password) is str
        :param salt: (optional) provide a bytes-like salt for hashing
        only applicable for pbkdf2 hashes.
        :return: str(hash)
        This method generates a hash pertaining to a specified algorithm,
        see supported_hash_algorithms.
        """

        if self.algorithm == "argon2id":
            from argon2 import PasswordHasher
            ph = PasswordHasher()
            return ph.hash(password)

        elif self.algorithm.startswith("pbkdf2:"):
            from hashlib import pbkdf2_hmac
            from os import urandom

            default_params = {
                "iterations": 300000,
            }

            for key in cost_params:
                if key not in default_params:
                    raise TypeError(f"'{key}' is not a valid cost parameter for {self.algorithm}.")

            final_params = default_params | cost_params
            iterations = final_params.get("iterations")

            if not iterations or not isinstance(iterations, int):
                raise TypeError(f"'{iterations}' is not a valid cost parameter for {self.algorithm}.")

            # Encoding password string to bytes
            byte_password = password.encode("utf-8")

            # self.algorithm = pbkdf2:sha---
            # self.algorithm.split(":")[1] = `sha---`
            sha_variant = self.algorithm.split(":")[1]

            if not salt:
                # Using OS RNG
                salt = urandom(16)

            h = pbkdf2_hmac(sha_variant, byte_password, salt, iterations).hex()
            hash_prefix = f"$pbkdf2:{sha_variant}:{iterations}"

            return f"{hash_prefix}${salt.hex()}${h}"

        elif self.algorithm == "bcrypt":
            from bcrypt import hashpw, gensalt

            default_params = {
                "iterations": 13, # Default Iterations = 2^13
            }

            for key in cost_params:
                if key not in default_params:
                    raise TypeError(f"'{key}' is not a valid cost parameter for {self.algorithm}.")

            final_params = default_params | cost_params
            iterations = final_params.get("iterations")

            if not iterations or not isinstance(iterations, int):
                raise TypeError(f"'{iterations}' is not a valid cost parameter for {self.algorithm}.")

            if not salt:
                # Salt generated by bcrypt
                salt = gensalt(iterations)

            else:
                salt_check = salt.endswith(b".") or salt.endswith(b"O") or salt.endswith(b"e") or salt.endswith(b"u")
                if not salt_check:
                    raise (TypeError("Invalid Salt\n(AuthAlpha): The salt must end with '.', 'O', "
                                     "'e' or 'u' in bcrypt. See https://github.com/Theorist-Git/AuthAlpha/commit"
                                     "/b00b7ce1b33c64d61da85ea2b657617008f16abe"))
                if len(salt) != BCRYPT_B64_SALT_LEN:
                    raise TypeError("salt must be 22 base 64 encoded character or 16 bytes long. Eg: \n "
                                    "'XeFRr+UT49ZF0DKDyIPMh.'")
                salt = b"$" + b"2b" + b"$" + ("%2.2u" % iterations).encode("ascii") + b"$" + salt

            return f"$bcrypt{hashpw(password.encode('utf-8'), salt).decode('utf-8')}"

        elif self.algorithm == "scrypt":
            from hashlib import scrypt
            from os import urandom

            default_params = {
                "log2n"     : 14,  # Default Iterations = 1 << n
                "r"         : 8,
                "p"         : 1,
                "maxmem"    : 128 * (1 << 14) * 8 + SCRYPT_MEM_BUFFER # Added 1 MiB buffer
            }

            for key in cost_params:
                if key not in default_params:
                    raise TypeError(f"'{key}' is not a valid cost parameter for {self.algorithm}.")

            final_params = default_params | cost_params

            log2n  = final_params.get("log2n")
            r      = final_params.get("r")
            p      = final_params.get("p")
            maxmem = final_params.get("maxmem")

            check_param_existence = log2n and r and p and maxmem
            check_param_dtype = isinstance(log2n, int) and isinstance(r, int) and isinstance(p, int) \
                                                                                and isinstance(maxmem, int)

            if not check_param_existence or not check_param_dtype:
                raise TypeError(f"Invalid cost parameters for {self.algorithm}.")

            if maxmem < 128 * (1 << log2n) * r:
                raise ValueError(f"`maxmem` for log2n and r must be at least 128 * (1 << log2n) * r = \
                                                                                            {128 * (1 << log2n) * r}")

            byte_password = password.encode("utf-8")

            if not salt:
                # Generating a random salt of 16 bytes
                salt = urandom(16)

            hashed = scrypt(
                password=byte_password,
                salt=salt,
                n=1 << log2n,
                r=r,
                p=p,
                maxmem=maxmem
            ).hex()

            return f"$scrypt$N={log2n}$r={r}$p={p}${salt.hex()}${hashed}"

        else:
            raise TypeError(f"Unsupported algorithm `{self.algorithm}`\nTry using the "
                            f"following\n"
                            f"{self.supported_hash_methods}")

    def check_password_hash(self, secret: str, password: str) -> bool:
        """
        Checks a plain text password against a provides hash of a supported algorithm
        see supported_hash_types
        :param secret: hash digest of a certain algorithm
        :param password: Plain-text password
        :return: True or False (password is correct or not)
        """
        if secret.startswith("$argon"):
            from argon2 import PasswordHasher, exceptions
            crypt_er = PasswordHasher()
            try:
                return crypt_er.verify(secret, password)
            except (exceptions.VerifyMismatchError, exceptions.InvalidHash, exceptions.VerificationError):
                return False

        elif secret.startswith("$pbkdf2"):
            try:
                # Example: $pbkdf2:sha256:300000$a1b2c3...$d4e5f6...
                _, method, salt_hex, hash_hex = secret.split('$', 3)

                _, sha_variant, iterations_str = method.split(':')
                iterations = int(iterations_str)

                salt_bytes = bytes.fromhex(salt_hex)

            except (ValueError, IndexError, TypeError):
                return False

            from hmac import compare_digest
            from hashlib import pbkdf2_hmac

            hash_to_check = pbkdf2_hmac(
                hash_name=sha_variant,
                password=password.encode("utf-8"),
                salt=salt_bytes,
                iterations=iterations,
            ).hex()

            return compare_digest(
                hash_to_check,
                hash_hex
            )

        elif secret.startswith("$bcrypt"):
            from bcrypt import checkpw
            hashed_password = secret.split("$bcrypt")[-1]

            try:
                return checkpw(password.encode("utf-8"), hashed_password.encode('utf-8'))
            except (ValueError, TypeError):
                return False

        elif secret.startswith("$scrypt"):
            from hmac import compare_digest
            from hashlib import scrypt

            try:
                _, method, log2n_str, r_str, p_str, salt_hex, hash_hex = secret.split('$', 6)
                log2n = int(log2n_str.split("=")[1])
                r = int(r_str.split("=")[1])
                p = int(p_str.split("=")[1])
                salt_bytes = bytes.fromhex(salt_hex)
                maxmem = 128 * (1 << log2n) * r + SCRYPT_MEM_BUFFER

            except (ValueError, IndexError, TypeError):
                return False

            try:
                hash_to_check = scrypt(
                    password=password.encode("utf-8"),
                    salt=salt_bytes,
                    n=1 << log2n,
                    r=r,
                    p=p,
                    maxmem=maxmem
                ).hex()
            except (ValueError, TypeError):
                return False

            return compare_digest(hash_to_check, hash_hex)

        else:
            raise TypeError(f"Unsupported Hash-Type: `{secret}` for algorithm `{self.algorithm}`\nTry using the "
                            f"following\n"
                            f"{self.supported_hash_methods}")


if __name__ == '__main__':

    hashes_to_hashes = PassHashing("argon2id")
    # This section illustrates common errors and their work-around
    # If you provide a hash digest which is not recognized Type error will be raised
    # check_hash("NOTRECOGNIZED", 1234567890)
    print(hashes_to_hashes)

    # You can catch the above exception like so:

    try:
        hashes_to_hashes.check_password_hash("NOTRECOGNIZED", str(1234567890))
    except TypeError as e:
        print(e, "\n")

    # You can print Supported list on demand like this:

    print("Supported Hash Methods: \n", hashes_to_hashes.supported_hash_methods)

    # See <https://github.com/Theorist-Git/AuthAlpha> for tutorials.
